<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Hex Battle P2P</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', monospace; background: #1a1a1a; }
        #menu, #ui { position: absolute; width: 100%; height: 100%; pointer-events: none; }
        
        /* –°—Ç–∏–ª–∏ –º–µ–Ω—é */
        .panel {
            pointer-events: auto;
            background: #2b2b2b; 
            border: 1px solid #444;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            padding: 30px;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; width: 320px;
            color: #eee;
            border-radius: 8px;
        }
        h2 { margin-top: 0; color: #ffbd2e; letter-spacing: 2px; }
        input { 
            padding: 10px; width: 80%; margin-bottom: 15px; 
            background: #111; border: 1px solid #555; color: white; 
            text-align: center; border-radius: 4px;
        }
        button { 
            padding: 12px 24px; font-size: 14px; cursor: pointer; 
            background: #3a5f75; color: white; border: none; 
            border-radius: 4px; transition: 0.2s; width: 100%; margin-bottom: 10px;
        }
        button:hover { background: #4da3d4; }
        hr { border: 0; border-top: 1px solid #444; margin: 20px 0; }
        
        /* –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏–≥—Ä—ã */
        #status-bar {
            pointer-events: auto;
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 30px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 18px;
            border: 1px solid #444;
        }
        #db-log { 
            position: absolute; bottom: 10px; left: 10px; 
            color: #888; font-size: 12px; max-height: 150px; overflow: hidden; 
            text-shadow: 1px 1px 0 #000;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/alasql@1.7.3/dist/alasql.min.js"></script>
</head>
<body>

<!-- UI –°–õ–û–ô -->
<div id="menu">
    <div class="panel" id="loginPanel">
        <h2>HEX ARENA</h2>
        <input type="text" id="username" placeholder="–ò–º—è –≥–µ—Ä–æ—è" value="Knight">
        <button onclick="initHost()">–°–û–ó–î–ê–¢–¨ –ò–ì–†–£</button>
        <hr>
        <input type="text" id="hostIdInput" placeholder="ID –ö–æ–º–Ω–∞—Ç—ã">
        <button onclick="joinGame()">–ü–†–ò–°–û–ï–î–ò–ù–ò–¢–¨–°–Ø</button>
        <p id="menuMsg" style="color: #ff5555; font-size: 12px;"></p>
    </div>

    <div class="panel" id="lobbyPanel" style="display:none;">
        <h3 style="color:#4da3d4">–û–ñ–ò–î–ê–ù–ò–ï</h3>
        <p style="font-size: 12px; color: #aaa;">–û—Ç–ø—Ä–∞–≤—å —ç—Ç–æ—Ç ID –¥—Ä—É–≥—É:</p>
        <input type="text" id="myPeerId" readonly style="background: #000; border: 1px solid #4da3d4; color: #4da3d4; font-weight: bold;">
        <div id="loadingAnim">Waiting for player...</div>
    </div>
</div>

<div id="ui" style="display:none;">
    <div id="status-bar">–û–∂–∏–¥–∞–Ω–∏–µ...</div>
    <div id="db-log"></div>
</div>

<!-- –°–ö–†–ò–ü–¢ -->
<script>
// --- 1. –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–†–ê–°–ò–í–´–• SVG ---

function createTexture(svgContent) {
    const img = new Image();
    const svgBlob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);
    img.src = url;
    const tex = new THREE.Texture(img);
    img.onload = () => tex.needsUpdate = true;
    return tex;
}

// –¢–µ–∫—Å—Ç—É—Ä–∞ –ø–æ–ª–∞ (—á—É—Ç—å —Ç–µ–º–Ω–µ–µ)
const hexSVG = `<svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
    <defs>
        <linearGradient id="grad" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:#5a6e7c;stop-opacity:1" />
            <stop offset="100%" style="stop-color:#3b4d59;stop-opacity:1" />
        </linearGradient>
    </defs>
    <polygon points="100,5 195,52 195,148 100,195 5,148 5,52" fill="url(#grad)" stroke="#2c3e50" stroke-width="4"/>
    <path d="M100,5 L100,195 M5,52 L195,148 M195,52 L5,148" stroke="#ffffff" stroke-opacity="0.1" stroke-width="2"/>
</svg>`;

// –ö—Ä–∞—Å–∏–≤—ã–π —Ä—ã—Ü–∞—Ä—å (–í–∏–¥ —Å–≤–µ—Ä—Ö—É)
function getHeroSVG(color, secondaryColor) {
    return `<svg width="128" height="128" xmlns="http://www.w3.org/2000/svg">
        <!-- –¢–µ–Ω—å -->
        <ellipse cx="64" cy="75" rx="40" ry="20" fill="rgba(0,0,0,0.5)" />
        <!-- –ü–ª–∞—â -->
        <path d="M34,40 Q64,110 94,40 L84,90 Q64,100 44,90 Z" fill="${color}" stroke="#111" stroke-width="2"/>
        <!-- –ü–ª–µ—á–∏ (–î–æ—Å–ø–µ—Ö) -->
        <ellipse cx="64" cy="64" rx="35" ry="25" fill="#bdc3c7" stroke="#2c3e50" stroke-width="3"/>
        <!-- –ì–æ–ª–æ–≤–∞ (–®–ª–µ–º) -->
        <circle cx="64" cy="64" r="16" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
        <line x1="64" y1="50" x2="64" y2="78" stroke="#2c3e50" stroke-width="4"/>
        <line x1="50" y1="64" x2="78" y2="64" stroke="#2c3e50" stroke-width="4"/>
        <!-- –©–∏—Ç -->
        <path d="M25,50 Q15,64 25,78 L30,78 L30,50 Z" fill="${color}" stroke="#ecf0f1" stroke-width="2" transform="scale(1.5) translate(-5, 0)"/>
        <!-- –ú–µ—á -->
        <rect x="85" y="30" width="6" height="50" fill="#bdc3c7" stroke="#2c3e50" transform="rotate(20, 88, 80)"/>
        <rect x="80" y="70" width="16" height="4" fill="#7f8c8d" transform="rotate(20, 88, 80)"/>
    </svg>`;
}

// –ü–∞—É–∫
const spiderSVG = `<svg width="128" height="128" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="64" cy="70" rx="30" ry="15" fill="rgba(0,0,0,0.6)" />
    <!-- –õ–∞–ø—ã –ª–µ–≤—ã–µ -->
    <path d="M50,64 Q20,50 10,80 M50,70 Q15,80 10,100 M50,60 Q25,30 20,50" stroke="#111" stroke-width="4" fill="none"/>
    <!-- –õ–∞–ø—ã –ø—Ä–∞–≤—ã–µ -->
    <path d="M78,64 Q108,50 118,80 M78,70 Q113,80 118,100 M78,60 Q103,30 108,50" stroke="#111" stroke-width="4" fill="none"/>
    <!-- –¢–µ–ª–æ -->
    <circle cx="64" cy="80" r="20" fill="#2c3e50" stroke="black" stroke-width="2"/>
    <circle cx="64" cy="55" r="12" fill="#2c3e50" stroke="black" stroke-width="2"/>
    <!-- –ì–ª–∞–∑–∞ -->
    <circle cx="60" cy="50" r="3" fill="red"/>
    <circle cx="68" cy="50" r="3" fill="red"/>
    <!-- –†–∏—Å—É–Ω–æ–∫ –Ω–∞ —Å–ø–∏–Ω–µ -->
    <path d="M64,70 L64,90 M58,80 L70,80" stroke="red" stroke-width="2"/>
</svg>`;

const textures = {
    hex: createTexture(hexSVG),
    spider: createTexture(spiderSVG),
    p1: createTexture(getHeroSVG('#3498db', '#2980b9')), // –°–∏–Ω–∏–π
    p2: createTexture(getHeroSVG('#e74c3c', '#c0392b'))  // –ö—Ä–∞—Å–Ω—ã–π
};

// --- 2. THREE.JS –ò –ì–ï–û–ú–ï–¢–†–ò–Ø –°–ï–¢–ö–ò ---

let scene, camera, renderer, raycaster, mouse;
let gridGroup = new THREE.Group();
let entitiesGroup = new THREE.Group();
const hexRadius = 2.0; // –†–∞–∑–º–µ—Ä –≥–µ–∫—Å–∞
const hexHeight = Math.sqrt(3) * hexRadius; 
const hexWidth = 2 * hexRadius;

function init3D() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202025);

    // –ò–∑–æ–º–µ—Ç—Ä–∏—è
    const aspect = window.innerWidth / window.innerHeight;
    const d = 14;
    camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É –ø–æ–¥ —É–≥–ª–æ–º, —á—Ç–æ–±—ã –±—ã–ª–æ –ø–æ—Ö–æ–∂–µ –Ω–∞ RPG
    camera.position.set(0, 20, 15); 
    camera.lookAt(0, 0, -2);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // –û—Å–≤–µ—â–µ–Ω–∏–µ
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(10, 20, 10);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    scene.add(gridGroup);
    scene.add(entitiesGroup);

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();
    window.addEventListener('mousedown', onMouseDown);
    
    generateGrid(4); // –†–∞–¥–∏—É—Å —Å–µ—Ç–∫–∏ 4
    animate();
}

// –ü–†–ê–í–ò–õ–¨–ù–ê–Ø –ì–ï–ù–ï–†–ê–¶–ò–Ø –°–ï–¢–ö–ò (Pointy Top)
function generateGrid(radius) {
    gridGroup.clear();
    
    // –ú–∞—Ç–µ—Ä–∏–∞–ª
    const geometry = new THREE.CylinderGeometry(hexRadius - 0.1, hexRadius - 0.1, 0.5, 6);
    const material = new THREE.MeshLambertMaterial({ map: textures.hex });
    const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000, opacity: 0.3, transparent: true });

    for (let q = -radius; q <= radius; q++) {
        for (let r = -radius; r <= radius; r++) {
            if (Math.abs(q + r) <= radius) {
                // –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è Axial -> World (Pointy Top)
                const x = (Math.sqrt(3) * hexRadius) * (q + r/2);
                const z = (3/2 * hexRadius) * r;

                const tile = new THREE.Mesh(geometry, material);
                
                // !–í–ê–ñ–ù–û: –ü–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Ü–∏–ª–∏–Ω–¥—Ä –Ω–∞ 30 –≥—Ä–∞–¥—É—Å–æ–≤ (PI/6), —á—Ç–æ–±—ã —É–≥–ª—ã —Å–æ–º–∫–Ω—É–ª–∏—Å—å
                tile.rotation.y = Math.PI / 6; 
                
                tile.position.set(x, 0, z);
                tile.userData = { q, r }; // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã

                // –û–±–≤–æ–¥–∫–∞
                const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geometry), edgeMat);
                tile.add(edges);

                gridGroup.add(tile);
            }
        }
    }
}

// –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä –¥–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å—É—â–Ω–æ—Å—Ç–µ–π
function hexToWorld(q, r) {
    const x = (Math.sqrt(3) * hexRadius) * (q + r/2);
    const z = (3/2 * hexRadius) * r;
    return {x, z};
}

function renderState(state) {
    entitiesGroup.clear();

    // –†–µ–Ω–¥–µ—Ä –≥–µ—Ä–æ–µ–≤
    Object.values(state.players).forEach(p => {
        const map = p.color === 'blue' ? textures.p1 : textures.p2;
        const sprite = createEntitySprite(map, 3);
        const pos = hexToWorld(p.x, p.z);
        sprite.position.set(pos.x, 2, pos.z);
        entitiesGroup.add(sprite);
        
        // –¢–µ–∫—Å—Ç HP
        addTextLabel(pos.x, pos.z, `${p.name} [${p.hp}]`, '#fff');
    });

    // –†–µ–Ω–¥–µ—Ä –ø–∞—É–∫–æ–≤
    state.spiders.forEach(s => {
        const sprite = createEntitySprite(textures.spider, 2.5);
        const pos = hexToWorld(s.x, s.z);
        sprite.position.set(pos.x, 1.5, pos.z);
        entitiesGroup.add(sprite);
        addTextLabel(pos.x, pos.z, `HP: ${s.hp}`, '#ff5555');
    });

    // UI
    const myTurn = state.turn === myId;
    const bar = document.getElementById('status-bar');
    if (state.winner) {
        bar.innerText = `–ü–û–ë–ï–î–ò–¢–ï–õ–¨: ${state.winner}!`;
        bar.style.borderColor = 'gold';
        bar.style.color = 'gold';
    } else {
        bar.innerText = myTurn ? "–í–ê–® –•–û–î" : "–•–û–î –ü–†–û–¢–ò–í–ù–ò–ö–ê";
        bar.style.background = myTurn ? 'rgba(0, 100, 0, 0.8)' : 'rgba(100, 0, 0, 0.8)';
    }
}

function createEntitySprite(map, scale) {
    const mat = new THREE.SpriteMaterial({ map: map });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(scale, scale, 1);
    return sprite;
}

function addTextLabel(x, z, text, color) {
    // –ü—Ä–æ—Å—Ç–æ–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Å–ø—Ä–∞–π—Ç —á–µ—Ä–µ–∑ canvas
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 256; canvas.height = 64;
    ctx.fillStyle = color;
    ctx.font = "bold 24px monospace";
    ctx.textAlign = "center";
    ctx.fillText(text, 128, 40);
    
    const tex = new THREE.CanvasTexture(canvas);
    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
    sprite.position.set(x, 3.5, z); // –ß—É—Ç—å –≤—ã—à–µ –≥–æ–ª–æ–≤—ã
    sprite.scale.set(4, 1, 1);
    entitiesGroup.add(sprite);
}

function onMouseDown(e) {
    if (!isGameActive) return;
    
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    const intersects = raycaster.intersectObjects(gridGroup.children);
    if (intersects.length > 0) {
        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –∫–ª–∏–∫–∞
        const tile = intersects[0].object;
        const originalColor = tile.material.color.getHex();
        tile.material.color.set(0xffff00);
        setTimeout(() => tile.material.color.setHex(0xffffff), 150);
        
        const hex = tile.userData;
        sendAction(hex);
    }
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

// --- 3. –°–ï–¢–ï–í–ê–Ø –ß–ê–°–¢–¨ –ò –ë–ê–ó–ê –î–ê–ù–ù–´–• ---

let peer, conn, myId;
let isHost = false, isGameActive = false;
let gameState = { players: {}, spiders: [], turn: null, winner: null };

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
alasql("CREATE TABLE IF NOT EXISTS players (name STRING PRIMARY KEY, xp INT, level INT)");

function log(msg) {
    const d = document.getElementById('db-log');
    d.innerHTML = `<div>> ${msg}</div>` + d.innerHTML;
}

function grantXP(name, amount) {
    if (!alasql(`SELECT * FROM players WHERE name = "${name}"`).length) 
        alasql(`INSERT INTO players VALUES ("${name}", 0, 1)`);
    
    alasql(`UPDATE players SET xp = xp + ${amount} WHERE name = "${name}"`);
    
    const p = alasql(`SELECT * FROM players WHERE name = "${name}"`)[0];
    log(`DB: ${name} +${amount} XP (Total: ${p.xp})`);
    
    if (p.xp >= p.level * 50) {
        alasql(`UPDATE players SET level = level + 1, xp = 0 WHERE name = "${name}"`);
        log(`DB: üî• ${name} LEVEL UP! -> ${p.level + 1}`);
    }
}

function initHost() {
    const name = document.getElementById('username').value;
    myId = 'host-' + Math.floor(Math.random()*9999);
    isHost = true;
    
    peer = new Peer(myId);
    peer.on('open', id => {
        document.getElementById('loginPanel').style.display = 'none';
        document.getElementById('lobbyPanel').style.display = 'block';
        document.getElementById('myPeerId').value = id;
    });
    
    peer.on('connection', c => {
        conn = c;
        setupConn();
        conn.on('data', data => {
            if(data.type === 'join') startGame(name, data.name, conn.peer);
            if(data.type === 'move') handleMove(data.pid, data.hex);
        });
    });
}

function joinGame() {
    const name = document.getElementById('username').value;
    const hostId = document.getElementById('hostIdInput').value;
    if(!hostId) return;
    
    peer = new Peer();
    peer.on('open', id => {
        myId = id;
        conn = peer.connect(hostId);
        setupConn();
        conn.on('open', () => {
            conn.send({type: 'join', name: name});
            document.getElementById('menu').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            init3D();
        });
        conn.on('data', data => {
            if(data.type === 'update') {
                gameState = data.state;
                renderState(gameState);
                isGameActive = true;
            }
        });
    });
}

function setupConn() {
    peer.on('error', err => alert("–û—à–∏–±–∫–∞: " + err));
}

function startGame(hostName, guestName, guestId) {
    gameState = {
        players: {
            [myId]: { x: -2, z: 0, hp: 5, color: 'blue', name: hostName },
            [guestId]: { x: 2, z: 0, hp: 5, color: 'red', name: guestName }
        },
        spiders: [
            {x: 0, z: -3, hp: 3}, {x: 0, z: 3, hp: 3}, {x: -3, z: 3, hp: 3}
        ],
        turn: myId,
        winner: null
    };
    
    document.getElementById('menu').style.display = 'none';
    document.getElementById('ui').style.display = 'block';
    init3D();
    isGameActive = true;
    broadcast();
}

function sendAction(hex) {
    if (isHost) handleMove(myId, hex);
    else conn.send({ type: 'move', pid: myId, hex: hex });
}

function handleMove(pid, hex) {
    if (gameState.winner || gameState.turn !== pid) return;
    
    const p = gameState.players[pid];
    // –î–∏—Å—Ç–∞–Ω—Ü–∏—è –Ω–∞ –≥–µ–∫—Å–∞–≥–æ–Ω–∞–ª—å–Ω–æ–π —Å–µ—Ç–∫–µ
    const dist = (Math.abs(p.x - hex.q) + Math.abs(p.x + p.z - hex.q - hex.r) + Math.abs(p.z - hex.r)) / 2;
    
    if (dist > 1.1) return; // –¢–æ–ª—å–∫–æ —Å–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–∞—É–∫–∞
    let sIdx = gameState.spiders.findIndex(s => s.x === hex.q && s.z === hex.r);
    if (sIdx !== -1) {
        gameState.spiders[sIdx].hp--;
        if(gameState.spiders[sIdx].hp <= 0) {
            gameState.spiders.splice(sIdx, 1);
            grantXP(p.name, 25);
        }
    } else {
        // –ê—Ç–∞–∫–∞ –∏–≥—Ä–æ–∫–∞?
        let enemyId = Object.keys(gameState.players).find(id => id !== pid);
        let enemy = gameState.players[enemyId];
        if (enemy.x === hex.q && enemy.z === hex.r) {
            enemy.hp--;
            if (enemy.hp <= 0) gameState.winner = p.name;
        } else {
            // –î–≤–∏–∂–µ–Ω–∏–µ
            p.x = hex.q;
            p.z = hex.r;
        }
    }
    
    // –°–º–µ–Ω–∞ —Ö–æ–¥–∞
    const ids = Object.keys(gameState.players);
    const next = ids[(ids.indexOf(pid) + 1) % ids.length];
    gameState.turn = next;
    
    if (next === ids[0]) moveAI();
    
    broadcast();
}

function moveAI() {
    gameState.spiders.forEach(s => {
        let target = null, minD = 999;
        Object.values(gameState.players).forEach(p => {
            let d = Math.sqrt((s.x - p.x)**2 + (s.z - p.z)**2);
            if(d < minD) { minD = d; target = p; }
        });
        
        if (target) {
            if (minD <= 1.5) {
                target.hp--;
                if (target.hp <= 0) gameState.winner = "SPIDERS";
            } else {
                // –ü—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–π –ø–æ–∏—Å–∫ –ø—É—Ç–∏
                if (s.x < target.x) s.x++; else if (s.x > target.x) s.x--;
                else if (s.z < target.z) s.z++; else if (s.z > target.z) s.z--;
            }
        }
    });
}

function broadcast() {
    renderState(gameState);
    if(conn) conn.send({ type: 'update', state: gameState });
}

// –†–µ—Å–∞–π–∑ –æ–∫–Ω–∞
window.addEventListener('resize', () => {
    const aspect = window.innerWidth / window.innerHeight;
    camera.left = -14 * aspect; camera.right = 14 * aspect;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
